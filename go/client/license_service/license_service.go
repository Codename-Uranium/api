// Package license_service provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package license_service

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	externalRef1 "github.com/vpnhouse/api/go/server/common"
)

const (
	ServiceKeyScopes  = "ServiceKey.Scopes"
	ServiceNameScopes = "ServiceName.Scopes"
)

// ApplyParams defines model for ApplyParams.
type ApplyParams struct {
	Email          *string `json:"email,omitempty"`
	InstallationId *string `json:"installation_id,omitempty"`
	ProjectId      *string `json:"project_id,omitempty"`
	UserId         *string `json:"user_id,omitempty"`
}

// CreateLicenseParams defines model for CreateLicenseParams.
type CreateLicenseParams struct {
	Disabled         *bool                   `json:"disabled"`
	EndAt            *time.Time              `json:"end_at"`
	EntitlementsJson *map[string]interface{} `json:"entitlements_json"`
	InstallationId   *string                 `json:"installation_id"`
	ProjectId        *string                 `json:"project_id"`
	PurchaseJson     *map[string]interface{} `json:"purchase_json"`
	SelectorJson     *map[string]interface{} `json:"selector_json"`
	StartAt          *time.Time              `json:"start_at"`
	UserId           *string                 `json:"user_id"`
}

// CreateProductParams defines model for CreateProductParams.
type CreateProductParams struct {
	Disabled     *bool                   `json:"disabled"`
	Name         *string                 `json:"name"`
	PaymentJson  *map[string]interface{} `json:"payment_json"`
	Period       *string                 `json:"period"`
	SelectorJson *map[string]interface{} `json:"selector_json"`
	Slug         *string                 `json:"slug"`
}

// CreatePurchaseParams defines model for CreatePurchaseParams.
type CreatePurchaseParams struct {
	Email            *string                 `json:"email"`
	EndAt            *time.Time              `json:"end_at"`
	EntitlementsJson *map[string]interface{} `json:"entitlements_json"`
	PurchaseJson     *map[string]interface{} `json:"purchase_json"`
	SelectorJson     *map[string]interface{} `json:"selector_json"`
	StartAt          *time.Time              `json:"start_at"`
	UserId           *string                 `json:"user_id"`
}

// FindLicenseParams defines model for FindLicenseParams.
type FindLicenseParams struct {
	CreatedAt        *time.Time              `json:"created_at,omitempty"`
	Disabled         *bool                   `json:"disabled,omitempty"`
	EndAt            *time.Time              `json:"end_at,omitempty"`
	EntitlementsJson *map[string]interface{} `json:"entitlements_json,omitempty"`
	InstallationId   *string                 `json:"installation_id,omitempty"`
	ProjectId        *string                 `json:"project_id,omitempty"`
	PurchaseJson     *map[string]interface{} `json:"purchase_json,omitempty"`
	SelectorJson     *map[string]interface{} `json:"selector_json,omitempty"`
	StartAt          *time.Time              `json:"start_at,omitempty"`
	UpdatedAt        *time.Time              `json:"updated_at,omitempty"`
	UserId           *string                 `json:"user_id,omitempty"`
}

// FindProductParams defines model for FindProductParams.
type FindProductParams struct {
	CreatedAt    *time.Time              `json:"created_at,omitempty"`
	Disabled     *bool                   `json:"disabled,omitempty"`
	Name         *string                 `json:"name,omitempty"`
	PaymentJson  *map[string]interface{} `json:"payment_json,omitempty"`
	Period       *string                 `json:"period,omitempty"`
	SelectorJson *map[string]interface{} `json:"selector_json,omitempty"`
	Slug         *string                 `json:"slug,omitempty"`
	UpdatedAt    *time.Time              `json:"updated_at,omitempty"`
}

// FindPurchaseParams defines model for FindPurchaseParams.
type FindPurchaseParams struct {
	CreatedAt        *time.Time              `json:"created_at,omitempty"`
	Email            *string                 `json:"email,omitempty"`
	EndAt            *time.Time              `json:"end_at,omitempty"`
	EntitlementsJson *map[string]interface{} `json:"entitlements_json,omitempty"`
	PurchaseJson     *map[string]interface{} `json:"purchase_json,omitempty"`
	SelectorJson     *map[string]interface{} `json:"selector_json,omitempty"`
	StartAt          *time.Time              `json:"start_at,omitempty"`
	UpdatedAt        *time.Time              `json:"updated_at,omitempty"`
	UserId           *string                 `json:"user_id,omitempty"`
}

// License defines model for License.
type License struct {
	CreatedAt        *time.Time              `json:"created_at,omitempty"`
	Disabled         *bool                   `json:"disabled,omitempty"`
	EndAt            *time.Time              `json:"end_at,omitempty"`
	EntitlementsJson *map[string]interface{} `json:"entitlements_json,omitempty"`
	Id               *string                 `json:"id,omitempty"`
	InstallationId   *string                 `json:"installation_id,omitempty"`
	ProjectId        *string                 `json:"project_id,omitempty"`
	PurchaseJson     *map[string]interface{} `json:"purchase_json,omitempty"`
	SelectorJson     *map[string]interface{} `json:"selector_json,omitempty"`
	StartAt          *time.Time              `json:"start_at,omitempty"`
	UpdatedAt        *time.Time              `json:"updated_at,omitempty"`
	UserId           *string                 `json:"user_id,omitempty"`
}

// PatchLicenseParams defines model for PatchLicenseParams.
type PatchLicenseParams struct {
	Disabled         *bool                   `json:"disabled,omitempty"`
	EndAt            *time.Time              `json:"end_at,omitempty"`
	EntitlementsJson *map[string]interface{} `json:"entitlements_json,omitempty"`
	InstallationId   *string                 `json:"installation_id,omitempty"`
	ProjectId        *string                 `json:"project_id,omitempty"`
	PurchaseJson     *map[string]interface{} `json:"purchase_json,omitempty"`
	SelectorJson     *map[string]interface{} `json:"selector_json,omitempty"`
	StartAt          *time.Time              `json:"start_at,omitempty"`
	UpdatedAt        *time.Time              `json:"updated_at"`
	UserId           *string                 `json:"user_id,omitempty"`
}

// PatchProductParams defines model for PatchProductParams.
type PatchProductParams struct {
	Disabled     *bool                   `json:"disabled,omitempty"`
	Name         *string                 `json:"name,omitempty"`
	PaymentJson  *map[string]interface{} `json:"payment_json,omitempty"`
	Period       *string                 `json:"period,omitempty"`
	SelectorJson *map[string]interface{} `json:"selector_json,omitempty"`
	Slug         *string                 `json:"slug,omitempty"`
	UpdatedAt    *time.Time              `json:"updated_at"`
}

// PatchPurchaseParams defines model for PatchPurchaseParams.
type PatchPurchaseParams struct {
	Email            *string                 `json:"email,omitempty"`
	EndAt            *time.Time              `json:"end_at,omitempty"`
	EntitlementsJson *map[string]interface{} `json:"entitlements_json,omitempty"`
	PurchaseJson     *map[string]interface{} `json:"purchase_json,omitempty"`
	SelectorJson     *map[string]interface{} `json:"selector_json,omitempty"`
	StartAt          *time.Time              `json:"start_at,omitempty"`
	UpdatedAt        *time.Time              `json:"updated_at"`
	UserId           *string                 `json:"user_id,omitempty"`
}

// Product defines model for Product.
type Product struct {
	CreatedAt    *time.Time              `json:"created_at,omitempty"`
	Disabled     *bool                   `json:"disabled,omitempty"`
	Id           *string                 `json:"id,omitempty"`
	Name         *string                 `json:"name,omitempty"`
	PaymentJson  *map[string]interface{} `json:"payment_json,omitempty"`
	Period       *string                 `json:"period,omitempty"`
	SelectorJson *map[string]interface{} `json:"selector_json,omitempty"`
	Slug         *string                 `json:"slug,omitempty"`
	UpdatedAt    *time.Time              `json:"updated_at,omitempty"`
}

// Purchase defines model for Purchase.
type Purchase struct {
	CreatedAt        *time.Time              `json:"created_at,omitempty"`
	Email            *string                 `json:"email,omitempty"`
	EndAt            *time.Time              `json:"end_at,omitempty"`
	EntitlementsJson *map[string]interface{} `json:"entitlements_json,omitempty"`
	Id               *string                 `json:"id,omitempty"`
	PurchaseJson     *map[string]interface{} `json:"purchase_json,omitempty"`
	SelectorJson     *map[string]interface{} `json:"selector_json,omitempty"`
	StartAt          *time.Time              `json:"start_at,omitempty"`
	UpdatedAt        *time.Time              `json:"updated_at,omitempty"`
	UserId           *string                 `json:"user_id,omitempty"`
}

// UpdateLicenseParams defines model for UpdateLicenseParams.
type UpdateLicenseParams struct {
	Disabled         *bool                   `json:"disabled"`
	EndAt            *time.Time              `json:"end_at"`
	EntitlementsJson *map[string]interface{} `json:"entitlements_json"`
	InstallationId   *string                 `json:"installation_id"`
	ProjectId        *string                 `json:"project_id"`
	PurchaseJson     *map[string]interface{} `json:"purchase_json"`
	SelectorJson     *map[string]interface{} `json:"selector_json"`
	StartAt          *time.Time              `json:"start_at"`
	UpdatedAt        *time.Time              `json:"updated_at"`
	UserId           *string                 `json:"user_id"`
}

// UpdateProductParams defines model for UpdateProductParams.
type UpdateProductParams struct {
	Disabled     *bool                   `json:"disabled"`
	Name         *string                 `json:"name"`
	PaymentJson  *map[string]interface{} `json:"payment_json"`
	Period       *string                 `json:"period"`
	SelectorJson *map[string]interface{} `json:"selector_json"`
	Slug         *string                 `json:"slug"`
	UpdatedAt    *time.Time              `json:"updated_at"`
}

// UpdatePurchaseParams defines model for UpdatePurchaseParams.
type UpdatePurchaseParams struct {
	Email            *string                 `json:"email"`
	EndAt            *time.Time              `json:"end_at"`
	EntitlementsJson *map[string]interface{} `json:"entitlements_json"`
	PurchaseJson     *map[string]interface{} `json:"purchase_json"`
	SelectorJson     *map[string]interface{} `json:"selector_json"`
	StartAt          *time.Time              `json:"start_at"`
	UpdatedAt        *time.Time              `json:"updated_at"`
	UserId           *string                 `json:"user_id"`
}

// ApplyForUserByEmailJSONBody defines parameters for ApplyForUserByEmail.
type ApplyForUserByEmailJSONBody ApplyParams

// FindLicenseJSONBody defines parameters for FindLicense.
type FindLicenseJSONBody FindLicenseParams

// FindProductJSONBody defines parameters for FindProduct.
type FindProductJSONBody FindProductParams

// FindPurchaseJSONBody defines parameters for FindPurchase.
type FindPurchaseJSONBody FindPurchaseParams

// ListLicenseParams defines parameters for ListLicense.
type ListLicenseParams struct {
	Limit  int `json:"limit"`
	Offset int `json:"offset"`
}

// CreateLicenseJSONBody defines parameters for CreateLicense.
type CreateLicenseJSONBody CreateLicenseParams

// PatchLicenseJSONBody defines parameters for PatchLicense.
type PatchLicenseJSONBody PatchLicenseParams

// UpdateLicenseJSONBody defines parameters for UpdateLicense.
type UpdateLicenseJSONBody UpdateLicenseParams

// ListProductParams defines parameters for ListProduct.
type ListProductParams struct {
	Limit  int `json:"limit"`
	Offset int `json:"offset"`
}

// CreateProductJSONBody defines parameters for CreateProduct.
type CreateProductJSONBody CreateProductParams

// PatchProductJSONBody defines parameters for PatchProduct.
type PatchProductJSONBody PatchProductParams

// UpdateProductJSONBody defines parameters for UpdateProduct.
type UpdateProductJSONBody UpdateProductParams

// ListPurchaseParams defines parameters for ListPurchase.
type ListPurchaseParams struct {
	Limit  int `json:"limit"`
	Offset int `json:"offset"`
}

// CreatePurchaseJSONBody defines parameters for CreatePurchase.
type CreatePurchaseJSONBody CreatePurchaseParams

// PatchPurchaseJSONBody defines parameters for PatchPurchase.
type PatchPurchaseJSONBody PatchPurchaseParams

// UpdatePurchaseJSONBody defines parameters for UpdatePurchase.
type UpdatePurchaseJSONBody UpdatePurchaseParams

// ApplyForUserByEmailJSONRequestBody defines body for ApplyForUserByEmail for application/json ContentType.
type ApplyForUserByEmailJSONRequestBody ApplyForUserByEmailJSONBody

// FindLicenseJSONRequestBody defines body for FindLicense for application/json ContentType.
type FindLicenseJSONRequestBody FindLicenseJSONBody

// FindProductJSONRequestBody defines body for FindProduct for application/json ContentType.
type FindProductJSONRequestBody FindProductJSONBody

// FindPurchaseJSONRequestBody defines body for FindPurchase for application/json ContentType.
type FindPurchaseJSONRequestBody FindPurchaseJSONBody

// CreateLicenseJSONRequestBody defines body for CreateLicense for application/json ContentType.
type CreateLicenseJSONRequestBody CreateLicenseJSONBody

// PatchLicenseJSONRequestBody defines body for PatchLicense for application/json ContentType.
type PatchLicenseJSONRequestBody PatchLicenseJSONBody

// UpdateLicenseJSONRequestBody defines body for UpdateLicense for application/json ContentType.
type UpdateLicenseJSONRequestBody UpdateLicenseJSONBody

// CreateProductJSONRequestBody defines body for CreateProduct for application/json ContentType.
type CreateProductJSONRequestBody CreateProductJSONBody

// PatchProductJSONRequestBody defines body for PatchProduct for application/json ContentType.
type PatchProductJSONRequestBody PatchProductJSONBody

// UpdateProductJSONRequestBody defines body for UpdateProduct for application/json ContentType.
type UpdateProductJSONRequestBody UpdateProductJSONBody

// CreatePurchaseJSONRequestBody defines body for CreatePurchase for application/json ContentType.
type CreatePurchaseJSONRequestBody CreatePurchaseJSONBody

// PatchPurchaseJSONRequestBody defines body for PatchPurchase for application/json ContentType.
type PatchPurchaseJSONRequestBody PatchPurchaseJSONBody

// UpdatePurchaseJSONRequestBody defines body for UpdatePurchase for application/json ContentType.
type UpdatePurchaseJSONRequestBody UpdatePurchaseJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ApplyForUserByEmail request with any body
	ApplyForUserByEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApplyForUserByEmail(ctx context.Context, body ApplyForUserByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindLicense request with any body
	FindLicenseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindLicense(ctx context.Context, body FindLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindProduct request with any body
	FindProductWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindProduct(ctx context.Context, body FindProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindPurchase request with any body
	FindPurchaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FindPurchase(ctx context.Context, body FindPurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLicense request
	ListLicense(ctx context.Context, params *ListLicenseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLicense request with any body
	CreateLicenseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLicense(ctx context.Context, body CreateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLicense request
	DeleteLicense(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicense request
	GetLicense(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchLicense request with any body
	PatchLicenseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchLicense(ctx context.Context, id string, body PatchLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLicense request with any body
	UpdateLicenseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLicense(ctx context.Context, id string, body UpdateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProduct request
	ListProduct(ctx context.Context, params *ListProductParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProduct request with any body
	CreateProductWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProduct(ctx context.Context, body CreateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProduct request
	DeleteProduct(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProduct request
	GetProduct(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchProduct request with any body
	PatchProductWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchProduct(ctx context.Context, id string, body PatchProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProduct request with any body
	UpdateProductWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProduct(ctx context.Context, id string, body UpdateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPurchase request
	ListPurchase(ctx context.Context, params *ListPurchaseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePurchase request with any body
	CreatePurchaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePurchase(ctx context.Context, body CreatePurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePurchase request
	DeletePurchase(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPurchase request
	GetPurchase(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchPurchase request with any body
	PatchPurchaseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchPurchase(ctx context.Context, id string, body PatchPurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePurchase request with any body
	UpdatePurchaseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePurchase(ctx context.Context, id string, body UpdatePurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ApplyForUserByEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApplyForUserByEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApplyForUserByEmail(ctx context.Context, body ApplyForUserByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApplyForUserByEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindLicenseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindLicenseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindLicense(ctx context.Context, body FindLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindLicenseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindProductWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindProductRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindProduct(ctx context.Context, body FindProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindProductRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPurchaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPurchaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindPurchase(ctx context.Context, body FindPurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindPurchaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLicense(ctx context.Context, params *ListLicenseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLicenseRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLicenseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLicenseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLicense(ctx context.Context, body CreateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLicenseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLicense(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLicenseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicense(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLicenseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLicenseRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchLicense(ctx context.Context, id string, body PatchLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchLicenseRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLicenseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLicenseRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLicense(ctx context.Context, id string, body UpdateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLicenseRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProduct(ctx context.Context, params *ListProductParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProductRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProductWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProductRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProduct(ctx context.Context, body CreateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProductRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProduct(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProduct(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchProductWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchProductRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchProduct(ctx context.Context, id string, body PatchProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchProductRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProductWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProduct(ctx context.Context, id string, body UpdateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProductRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPurchase(ctx context.Context, params *ListPurchaseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPurchaseRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePurchaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePurchaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePurchase(ctx context.Context, body CreatePurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePurchaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePurchase(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePurchaseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPurchase(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPurchaseRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPurchaseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPurchaseRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchPurchase(ctx context.Context, id string, body PatchPurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchPurchaseRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePurchaseWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePurchaseRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePurchase(ctx context.Context, id string, body UpdatePurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePurchaseRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewApplyForUserByEmailRequest calls the generic ApplyForUserByEmail builder with application/json body
func NewApplyForUserByEmailRequest(server string, body ApplyForUserByEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApplyForUserByEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewApplyForUserByEmailRequestWithBody generates requests for ApplyForUserByEmail with any type of body
func NewApplyForUserByEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/apply-for-user-by-email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindLicenseRequest calls the generic FindLicense builder with application/json body
func NewFindLicenseRequest(server string, body FindLicenseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindLicenseRequestWithBody(server, "application/json", bodyReader)
}

// NewFindLicenseRequestWithBody generates requests for FindLicense with any type of body
func NewFindLicenseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/find-license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindProductRequest calls the generic FindProduct builder with application/json body
func NewFindProductRequest(server string, body FindProductJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindProductRequestWithBody(server, "application/json", bodyReader)
}

// NewFindProductRequestWithBody generates requests for FindProduct with any type of body
func NewFindProductRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/find-product")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindPurchaseRequest calls the generic FindPurchase builder with application/json body
func NewFindPurchaseRequest(server string, body FindPurchaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFindPurchaseRequestWithBody(server, "application/json", bodyReader)
}

// NewFindPurchaseRequestWithBody generates requests for FindPurchase with any type of body
func NewFindPurchaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/find-purchase")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListLicenseRequest generates requests for ListLicense
func NewListLicenseRequest(server string, params *ListLicenseParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLicenseRequest calls the generic CreateLicense builder with application/json body
func NewCreateLicenseRequest(server string, body CreateLicenseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLicenseRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLicenseRequestWithBody generates requests for CreateLicense with any type of body
func NewCreateLicenseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLicenseRequest generates requests for DeleteLicense
func NewDeleteLicenseRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/license/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLicenseRequest generates requests for GetLicense
func NewGetLicenseRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/license/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchLicenseRequest calls the generic PatchLicense builder with application/json body
func NewPatchLicenseRequest(server string, id string, body PatchLicenseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchLicenseRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchLicenseRequestWithBody generates requests for PatchLicense with any type of body
func NewPatchLicenseRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/license/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateLicenseRequest calls the generic UpdateLicense builder with application/json body
func NewUpdateLicenseRequest(server string, id string, body UpdateLicenseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLicenseRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateLicenseRequestWithBody generates requests for UpdateLicense with any type of body
func NewUpdateLicenseRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/license/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProductRequest generates requests for ListProduct
func NewListProductRequest(server string, params *ListProductParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/product")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProductRequest calls the generic CreateProduct builder with application/json body
func NewCreateProductRequest(server string, body CreateProductJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProductRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProductRequestWithBody generates requests for CreateProduct with any type of body
func NewCreateProductRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/product")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProductRequest generates requests for DeleteProduct
func NewDeleteProductRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/product/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductRequest generates requests for GetProduct
func NewGetProductRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/product/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchProductRequest calls the generic PatchProduct builder with application/json body
func NewPatchProductRequest(server string, id string, body PatchProductJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchProductRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchProductRequestWithBody generates requests for PatchProduct with any type of body
func NewPatchProductRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/product/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateProductRequest calls the generic UpdateProduct builder with application/json body
func NewUpdateProductRequest(server string, id string, body UpdateProductJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProductRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateProductRequestWithBody generates requests for UpdateProduct with any type of body
func NewUpdateProductRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/product/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPurchaseRequest generates requests for ListPurchase
func NewListPurchaseRequest(server string, params *ListPurchaseParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/purchase")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePurchaseRequest calls the generic CreatePurchase builder with application/json body
func NewCreatePurchaseRequest(server string, body CreatePurchaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePurchaseRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePurchaseRequestWithBody generates requests for CreatePurchase with any type of body
func NewCreatePurchaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/purchase")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePurchaseRequest generates requests for DeletePurchase
func NewDeletePurchaseRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/purchase/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPurchaseRequest generates requests for GetPurchase
func NewGetPurchaseRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/purchase/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchPurchaseRequest calls the generic PatchPurchase builder with application/json body
func NewPatchPurchaseRequest(server string, id string, body PatchPurchaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchPurchaseRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchPurchaseRequestWithBody generates requests for PatchPurchase with any type of body
func NewPatchPurchaseRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/purchase/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdatePurchaseRequest calls the generic UpdatePurchase builder with application/json body
func NewUpdatePurchaseRequest(server string, id string, body UpdatePurchaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePurchaseRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdatePurchaseRequestWithBody generates requests for UpdatePurchase with any type of body
func NewUpdatePurchaseRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/license-service/purchase/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ApplyForUserByEmail request with any body
	ApplyForUserByEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplyForUserByEmailResponse, error)

	ApplyForUserByEmailWithResponse(ctx context.Context, body ApplyForUserByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplyForUserByEmailResponse, error)

	// FindLicense request with any body
	FindLicenseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindLicenseResponse, error)

	FindLicenseWithResponse(ctx context.Context, body FindLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*FindLicenseResponse, error)

	// FindProduct request with any body
	FindProductWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindProductResponse, error)

	FindProductWithResponse(ctx context.Context, body FindProductJSONRequestBody, reqEditors ...RequestEditorFn) (*FindProductResponse, error)

	// FindPurchase request with any body
	FindPurchaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindPurchaseResponse, error)

	FindPurchaseWithResponse(ctx context.Context, body FindPurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*FindPurchaseResponse, error)

	// ListLicense request
	ListLicenseWithResponse(ctx context.Context, params *ListLicenseParams, reqEditors ...RequestEditorFn) (*ListLicenseResponse, error)

	// CreateLicense request with any body
	CreateLicenseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLicenseResponse, error)

	CreateLicenseWithResponse(ctx context.Context, body CreateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLicenseResponse, error)

	// DeleteLicense request
	DeleteLicenseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLicenseResponse, error)

	// GetLicense request
	GetLicenseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLicenseResponse, error)

	// PatchLicense request with any body
	PatchLicenseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLicenseResponse, error)

	PatchLicenseWithResponse(ctx context.Context, id string, body PatchLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLicenseResponse, error)

	// UpdateLicense request with any body
	UpdateLicenseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLicenseResponse, error)

	UpdateLicenseWithResponse(ctx context.Context, id string, body UpdateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLicenseResponse, error)

	// ListProduct request
	ListProductWithResponse(ctx context.Context, params *ListProductParams, reqEditors ...RequestEditorFn) (*ListProductResponse, error)

	// CreateProduct request with any body
	CreateProductWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProductResponse, error)

	CreateProductWithResponse(ctx context.Context, body CreateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProductResponse, error)

	// DeleteProduct request
	DeleteProductWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProductResponse, error)

	// GetProduct request
	GetProductWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetProductResponse, error)

	// PatchProduct request with any body
	PatchProductWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchProductResponse, error)

	PatchProductWithResponse(ctx context.Context, id string, body PatchProductJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchProductResponse, error)

	// UpdateProduct request with any body
	UpdateProductWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductResponse, error)

	UpdateProductWithResponse(ctx context.Context, id string, body UpdateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductResponse, error)

	// ListPurchase request
	ListPurchaseWithResponse(ctx context.Context, params *ListPurchaseParams, reqEditors ...RequestEditorFn) (*ListPurchaseResponse, error)

	// CreatePurchase request with any body
	CreatePurchaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePurchaseResponse, error)

	CreatePurchaseWithResponse(ctx context.Context, body CreatePurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePurchaseResponse, error)

	// DeletePurchase request
	DeletePurchaseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePurchaseResponse, error)

	// GetPurchase request
	GetPurchaseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPurchaseResponse, error)

	// PatchPurchase request with any body
	PatchPurchaseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPurchaseResponse, error)

	PatchPurchaseWithResponse(ctx context.Context, id string, body PatchPurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPurchaseResponse, error)

	// UpdatePurchase request with any body
	UpdatePurchaseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePurchaseResponse, error)

	UpdatePurchaseWithResponse(ctx context.Context, id string, body UpdatePurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePurchaseResponse, error)
}

type ApplyForUserByEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]License
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r ApplyForUserByEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApplyForUserByEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]License
	JSON400      *externalRef1.Error
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON409      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r FindLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Product
	JSON400      *externalRef1.Error
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON409      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r FindProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindPurchaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Purchase
	JSON400      *externalRef1.Error
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON409      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r FindPurchaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindPurchaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]License
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r ListLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *externalRef1.Error
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON409      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r CreateLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r DeleteLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *License
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r GetLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *externalRef1.Error
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON409      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r PatchLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLicenseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *externalRef1.Error
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON409      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r UpdateLicenseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLicenseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Product
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r ListProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *externalRef1.Error
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON409      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r CreateProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r DeleteProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Product
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r GetProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *externalRef1.Error
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON409      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r PatchProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *externalRef1.Error
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON409      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r UpdateProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPurchaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Purchase
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r ListPurchaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPurchaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePurchaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *externalRef1.Error
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON409      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r CreatePurchaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePurchaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePurchaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r DeletePurchaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePurchaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPurchaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Purchase
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r GetPurchaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPurchaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchPurchaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *externalRef1.Error
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON409      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r PatchPurchaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchPurchaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePurchaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *externalRef1.Error
	JSON401      *externalRef1.Error
	JSON403      *externalRef1.Error
	JSON409      *externalRef1.Error
	JSON500      *externalRef1.Error
}

// Status returns HTTPResponse.Status
func (r UpdatePurchaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePurchaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ApplyForUserByEmailWithBodyWithResponse request with arbitrary body returning *ApplyForUserByEmailResponse
func (c *ClientWithResponses) ApplyForUserByEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApplyForUserByEmailResponse, error) {
	rsp, err := c.ApplyForUserByEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApplyForUserByEmailResponse(rsp)
}

func (c *ClientWithResponses) ApplyForUserByEmailWithResponse(ctx context.Context, body ApplyForUserByEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*ApplyForUserByEmailResponse, error) {
	rsp, err := c.ApplyForUserByEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApplyForUserByEmailResponse(rsp)
}

// FindLicenseWithBodyWithResponse request with arbitrary body returning *FindLicenseResponse
func (c *ClientWithResponses) FindLicenseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindLicenseResponse, error) {
	rsp, err := c.FindLicenseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindLicenseResponse(rsp)
}

func (c *ClientWithResponses) FindLicenseWithResponse(ctx context.Context, body FindLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*FindLicenseResponse, error) {
	rsp, err := c.FindLicense(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindLicenseResponse(rsp)
}

// FindProductWithBodyWithResponse request with arbitrary body returning *FindProductResponse
func (c *ClientWithResponses) FindProductWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindProductResponse, error) {
	rsp, err := c.FindProductWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindProductResponse(rsp)
}

func (c *ClientWithResponses) FindProductWithResponse(ctx context.Context, body FindProductJSONRequestBody, reqEditors ...RequestEditorFn) (*FindProductResponse, error) {
	rsp, err := c.FindProduct(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindProductResponse(rsp)
}

// FindPurchaseWithBodyWithResponse request with arbitrary body returning *FindPurchaseResponse
func (c *ClientWithResponses) FindPurchaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FindPurchaseResponse, error) {
	rsp, err := c.FindPurchaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPurchaseResponse(rsp)
}

func (c *ClientWithResponses) FindPurchaseWithResponse(ctx context.Context, body FindPurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*FindPurchaseResponse, error) {
	rsp, err := c.FindPurchase(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindPurchaseResponse(rsp)
}

// ListLicenseWithResponse request returning *ListLicenseResponse
func (c *ClientWithResponses) ListLicenseWithResponse(ctx context.Context, params *ListLicenseParams, reqEditors ...RequestEditorFn) (*ListLicenseResponse, error) {
	rsp, err := c.ListLicense(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLicenseResponse(rsp)
}

// CreateLicenseWithBodyWithResponse request with arbitrary body returning *CreateLicenseResponse
func (c *ClientWithResponses) CreateLicenseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLicenseResponse, error) {
	rsp, err := c.CreateLicenseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLicenseResponse(rsp)
}

func (c *ClientWithResponses) CreateLicenseWithResponse(ctx context.Context, body CreateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLicenseResponse, error) {
	rsp, err := c.CreateLicense(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLicenseResponse(rsp)
}

// DeleteLicenseWithResponse request returning *DeleteLicenseResponse
func (c *ClientWithResponses) DeleteLicenseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLicenseResponse, error) {
	rsp, err := c.DeleteLicense(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLicenseResponse(rsp)
}

// GetLicenseWithResponse request returning *GetLicenseResponse
func (c *ClientWithResponses) GetLicenseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLicenseResponse, error) {
	rsp, err := c.GetLicense(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseResponse(rsp)
}

// PatchLicenseWithBodyWithResponse request with arbitrary body returning *PatchLicenseResponse
func (c *ClientWithResponses) PatchLicenseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchLicenseResponse, error) {
	rsp, err := c.PatchLicenseWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLicenseResponse(rsp)
}

func (c *ClientWithResponses) PatchLicenseWithResponse(ctx context.Context, id string, body PatchLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchLicenseResponse, error) {
	rsp, err := c.PatchLicense(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchLicenseResponse(rsp)
}

// UpdateLicenseWithBodyWithResponse request with arbitrary body returning *UpdateLicenseResponse
func (c *ClientWithResponses) UpdateLicenseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLicenseResponse, error) {
	rsp, err := c.UpdateLicenseWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLicenseResponse(rsp)
}

func (c *ClientWithResponses) UpdateLicenseWithResponse(ctx context.Context, id string, body UpdateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLicenseResponse, error) {
	rsp, err := c.UpdateLicense(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLicenseResponse(rsp)
}

// ListProductWithResponse request returning *ListProductResponse
func (c *ClientWithResponses) ListProductWithResponse(ctx context.Context, params *ListProductParams, reqEditors ...RequestEditorFn) (*ListProductResponse, error) {
	rsp, err := c.ListProduct(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProductResponse(rsp)
}

// CreateProductWithBodyWithResponse request with arbitrary body returning *CreateProductResponse
func (c *ClientWithResponses) CreateProductWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProductResponse, error) {
	rsp, err := c.CreateProductWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProductResponse(rsp)
}

func (c *ClientWithResponses) CreateProductWithResponse(ctx context.Context, body CreateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProductResponse, error) {
	rsp, err := c.CreateProduct(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProductResponse(rsp)
}

// DeleteProductWithResponse request returning *DeleteProductResponse
func (c *ClientWithResponses) DeleteProductWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteProductResponse, error) {
	rsp, err := c.DeleteProduct(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductResponse(rsp)
}

// GetProductWithResponse request returning *GetProductResponse
func (c *ClientWithResponses) GetProductWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetProductResponse, error) {
	rsp, err := c.GetProduct(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductResponse(rsp)
}

// PatchProductWithBodyWithResponse request with arbitrary body returning *PatchProductResponse
func (c *ClientWithResponses) PatchProductWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchProductResponse, error) {
	rsp, err := c.PatchProductWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchProductResponse(rsp)
}

func (c *ClientWithResponses) PatchProductWithResponse(ctx context.Context, id string, body PatchProductJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchProductResponse, error) {
	rsp, err := c.PatchProduct(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchProductResponse(rsp)
}

// UpdateProductWithBodyWithResponse request with arbitrary body returning *UpdateProductResponse
func (c *ClientWithResponses) UpdateProductWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProductResponse, error) {
	rsp, err := c.UpdateProductWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductResponse(rsp)
}

func (c *ClientWithResponses) UpdateProductWithResponse(ctx context.Context, id string, body UpdateProductJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProductResponse, error) {
	rsp, err := c.UpdateProduct(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProductResponse(rsp)
}

// ListPurchaseWithResponse request returning *ListPurchaseResponse
func (c *ClientWithResponses) ListPurchaseWithResponse(ctx context.Context, params *ListPurchaseParams, reqEditors ...RequestEditorFn) (*ListPurchaseResponse, error) {
	rsp, err := c.ListPurchase(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPurchaseResponse(rsp)
}

// CreatePurchaseWithBodyWithResponse request with arbitrary body returning *CreatePurchaseResponse
func (c *ClientWithResponses) CreatePurchaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePurchaseResponse, error) {
	rsp, err := c.CreatePurchaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePurchaseResponse(rsp)
}

func (c *ClientWithResponses) CreatePurchaseWithResponse(ctx context.Context, body CreatePurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePurchaseResponse, error) {
	rsp, err := c.CreatePurchase(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePurchaseResponse(rsp)
}

// DeletePurchaseWithResponse request returning *DeletePurchaseResponse
func (c *ClientWithResponses) DeletePurchaseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePurchaseResponse, error) {
	rsp, err := c.DeletePurchase(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePurchaseResponse(rsp)
}

// GetPurchaseWithResponse request returning *GetPurchaseResponse
func (c *ClientWithResponses) GetPurchaseWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetPurchaseResponse, error) {
	rsp, err := c.GetPurchase(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPurchaseResponse(rsp)
}

// PatchPurchaseWithBodyWithResponse request with arbitrary body returning *PatchPurchaseResponse
func (c *ClientWithResponses) PatchPurchaseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchPurchaseResponse, error) {
	rsp, err := c.PatchPurchaseWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPurchaseResponse(rsp)
}

func (c *ClientWithResponses) PatchPurchaseWithResponse(ctx context.Context, id string, body PatchPurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchPurchaseResponse, error) {
	rsp, err := c.PatchPurchase(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchPurchaseResponse(rsp)
}

// UpdatePurchaseWithBodyWithResponse request with arbitrary body returning *UpdatePurchaseResponse
func (c *ClientWithResponses) UpdatePurchaseWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePurchaseResponse, error) {
	rsp, err := c.UpdatePurchaseWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePurchaseResponse(rsp)
}

func (c *ClientWithResponses) UpdatePurchaseWithResponse(ctx context.Context, id string, body UpdatePurchaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePurchaseResponse, error) {
	rsp, err := c.UpdatePurchase(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePurchaseResponse(rsp)
}

// ParseApplyForUserByEmailResponse parses an HTTP response from a ApplyForUserByEmailWithResponse call
func ParseApplyForUserByEmailResponse(rsp *http.Response) (*ApplyForUserByEmailResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApplyForUserByEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []License
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFindLicenseResponse parses an HTTP response from a FindLicenseWithResponse call
func ParseFindLicenseResponse(rsp *http.Response) (*FindLicenseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []License
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFindProductResponse parses an HTTP response from a FindProductWithResponse call
func ParseFindProductResponse(rsp *http.Response) (*FindProductResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Product
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFindPurchaseResponse parses an HTTP response from a FindPurchaseWithResponse call
func ParseFindPurchaseResponse(rsp *http.Response) (*FindPurchaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindPurchaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Purchase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListLicenseResponse parses an HTTP response from a ListLicenseWithResponse call
func ParseListLicenseResponse(rsp *http.Response) (*ListLicenseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []License
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateLicenseResponse parses an HTTP response from a CreateLicenseWithResponse call
func ParseCreateLicenseResponse(rsp *http.Response) (*CreateLicenseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteLicenseResponse parses an HTTP response from a DeleteLicenseWithResponse call
func ParseDeleteLicenseResponse(rsp *http.Response) (*DeleteLicenseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLicenseResponse parses an HTTP response from a GetLicenseWithResponse call
func ParseGetLicenseResponse(rsp *http.Response) (*GetLicenseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest License
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchLicenseResponse parses an HTTP response from a PatchLicenseWithResponse call
func ParsePatchLicenseResponse(rsp *http.Response) (*PatchLicenseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateLicenseResponse parses an HTTP response from a UpdateLicenseWithResponse call
func ParseUpdateLicenseResponse(rsp *http.Response) (*UpdateLicenseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLicenseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProductResponse parses an HTTP response from a ListProductWithResponse call
func ParseListProductResponse(rsp *http.Response) (*ListProductResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Product
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProductResponse parses an HTTP response from a CreateProductWithResponse call
func ParseCreateProductResponse(rsp *http.Response) (*CreateProductResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductResponse parses an HTTP response from a DeleteProductWithResponse call
func ParseDeleteProductResponse(rsp *http.Response) (*DeleteProductResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductResponse parses an HTTP response from a GetProductWithResponse call
func ParseGetProductResponse(rsp *http.Response) (*GetProductResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Product
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchProductResponse parses an HTTP response from a PatchProductWithResponse call
func ParsePatchProductResponse(rsp *http.Response) (*PatchProductResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProductResponse parses an HTTP response from a UpdateProductWithResponse call
func ParseUpdateProductResponse(rsp *http.Response) (*UpdateProductResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPurchaseResponse parses an HTTP response from a ListPurchaseWithResponse call
func ParseListPurchaseResponse(rsp *http.Response) (*ListPurchaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPurchaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Purchase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePurchaseResponse parses an HTTP response from a CreatePurchaseWithResponse call
func ParseCreatePurchaseResponse(rsp *http.Response) (*CreatePurchaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePurchaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePurchaseResponse parses an HTTP response from a DeletePurchaseWithResponse call
func ParseDeletePurchaseResponse(rsp *http.Response) (*DeletePurchaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePurchaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPurchaseResponse parses an HTTP response from a GetPurchaseWithResponse call
func ParseGetPurchaseResponse(rsp *http.Response) (*GetPurchaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPurchaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Purchase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchPurchaseResponse parses an HTTP response from a PatchPurchaseWithResponse call
func ParsePatchPurchaseResponse(rsp *http.Response) (*PatchPurchaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchPurchaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdatePurchaseResponse parses an HTTP response from a UpdatePurchaseWithResponse call
func ParseUpdatePurchaseResponse(rsp *http.Response) (*UpdatePurchaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePurchaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef1.Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
